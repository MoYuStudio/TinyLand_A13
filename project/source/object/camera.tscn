[gd_scene load_steps=6 format=3 uid="uid://deyci4scpxkr8"]

[sub_resource type="GDScript" id="GDScript_k0qoa"]
script/source = "
extends Camera3D

@onready var 射线投影 := $RayCast

signal 碰撞点

var 移动速度 = 0.3

# 相机视角
var 最小可视角 = -90.0
var 最大可视角 = 90.0
var 视角灵敏度 = 30.0

# 向量
var 移动向量 = Vector3()
var 鼠标周期 = Vector2()
# var 鼠标位置 = Vector2()

var 碰撞点位置

var 鼠标锁定 = true

func _ready():
	pass
	
func _input(event):
	
	if 鼠标锁定 == true:
			
		if event is InputEventMouseMotion:
			鼠标周期 = event.relative
			_select_target(event.position)
			
		if event is InputEventMouseButton or event is InputEventScreenTouch:
			_select_target(event.position)

func _select_target(click_position: Vector2) -> void:
	var from = project_ray_origin(click_position)
	var to = from + project_ray_normal(click_position)*100
	var space_state = get_world_3d().direct_space_state
	var params = PhysicsRayQueryParameters3D.new()
	params.from = from
	params.to = to
	params.exclude = []
	params.collision_mask = 1
	射线投影.force_raycast_update()
	if 射线投影.is_colliding():
		var iray = space_state.intersect_ray(params)
		if iray:
			var 碰撞点位置 = iray['position']
			碰撞点位置 = Vector3(碰撞点位置[0],0,碰撞点位置[2])
			emit_signal('碰撞点', 碰撞点位置)

func _physics_process(delta):
	
	var camera_pos = position
	
	if 鼠标锁定 == true:
	
		var input = Vector3()
		
		# 输入
		if Input.is_action_pressed('Right_Click'):
			# 沿x轴旋转相机
			rotation_degrees.x -= 鼠标周期.y * 视角灵敏度 * delta

			# 夹紧相机x旋转轴
			rotation_degrees.x = clamp(rotation_degrees.x, 最小可视角, 最大可视角)

			# 沿 y 轴旋转玩家
			rotation_degrees.y -= 鼠标周期.x * 视角灵敏度 * delta

			# 重置 mouseDelta 向量
			鼠标周期 = Vector2()
			
			# 重置 x y z 速度
			移动向量.x = 0
			移动向量.y = 0
			移动向量.z = 0
			
		if Input.is_action_pressed('W'):
			input.z -= 1
		if Input.is_action_pressed('S'):
			input.z += 1
		if Input.is_action_pressed('A'):
			input.x -= 1
		if Input.is_action_pressed('D'):
			input.x += 1
		if Input.is_action_pressed('Space'):
			input.y += 1
		if Input.is_action_pressed('Shift'):
			if position.y >= 1.6: # 地平线限位
				input.y -= 1
		if Input.is_action_pressed('Ctrl'):
			移动速度 = 1.2
		else:
			移动速度 = 0.3
		
		input = input.normalized()
		
		# 获得前进和正确的方向
		var forward = global_transform.basis.z
		var right = global_transform.basis.x
		
		var relativeDir = (forward * input.z + right * input.x)
		
		# 设置速度
		移动向量.x = relativeDir.x * 移动速度
		移动向量.y = input.y * 移动速度
		移动向量.z = relativeDir.z * 移动速度
		
		position.x += 移动向量.x
		position.y += 移动向量.y
		position.z += 移动向量.z
		
	elif 鼠标锁定 == false:
		pass
"

[sub_resource type="Shader" id="Shader_a0xps"]
code = "
shader_type spatial;

render_mode unshaded;

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture;

const int pixel_size = 4; //resolution must be divisible by pixel_size

void fragment() {
	float x = float(int(FRAGCOORD.x) % pixel_size);
	float y = float(int(FRAGCOORD.y) % pixel_size);

	x = FRAGCOORD.x + floor(float(pixel_size) / 2.0) - x;
	y = FRAGCOORD.y + floor(float(pixel_size) / 2.0) - y;

	ALBEDO = texture(SCREEN_TEXTURE, vec2(x, y) / VIEWPORT_SIZE).xyz;
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_7xu87"]
render_priority = 0
shader = SubResource("Shader_a0xps")

[sub_resource type="PlaneMesh" id="PlaneMesh_ytnrx"]
material = SubResource("ShaderMaterial_7xu87")
size = Vector2(16, 16)

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_pwxoy"]

[node name="Camera" type="Camera3D"]
fov = 85.0
script = SubResource("GDScript_k0qoa")

[node name="RayCast" type="RayCast3D" parent="."]
target_position = Vector3(0, 0, -10)
collide_with_areas = true

[node name="Pixel" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, -4.37114e-08, -1, 0, 1, -4.37114e-08, 0, 0, -1)
visible = false
mesh = SubResource("PlaneMesh_ytnrx")
skeleton = NodePath("../..")

[node name="MeshInstance3D" type="Area3D" parent="."]

[node name="CollisionShape3D" type="CollisionShape3D" parent="MeshInstance3D"]
shape = SubResource("CapsuleShape3D_pwxoy")
